

# AWS EC2 + Docker + Nginx

### 목표 

* Docker와 Nginx를 이용해 reverse proxy 서버를 구축하고 
  Nginx를 하나 더 이용해 static 서버를 구성



# EC2

### 환경 : ubuntu 18.04 LTS





# Docker

### 설치

```bash
#도커 패키지 설치 전 업데이트 수행
$ sudo apt-get update

#도커 패키지 설치
$ sudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common

#도커GPG 키 추가
$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -

#도커 GPG 키 확인
$ sudo apt-key fingerprint 0EBFCD88

#터미널에서 아래와 같이 뜨면 OK
====================================================================
pub   rsa4096 2017-02-22 [SCEA]
      9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88
uid           [ unknown] Docker Release (CE deb) <docker@docker.com>
sub   rsa4096 2017-02-22 [S]
====================================================================



#docker 저장소 등록
$ sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"

#docker engine 설치
$ sudo apt-get update
sudo apt-get install docker-ce docker-ce-cli containerd.io

#docker engine 설치 확인
$ sudo docker run hello-world

#아래와 같이 나왔다면 설치 성공
====================================================================
Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
    (amd64)
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
 https://hub.docker.com/

For more examples and ideas, visit:
 https://docs.docker.com/get-started/
====================================================================

```



# Docker Compose

### 설치

```bash
#안정적인 버전인 1.29.1 설치
$ sudo curl -L "https://github.com/docker/compose/releases/download/1.29.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose

#docker compose 권한 적용
$ sudo chmod +x /usr/local/bin/docker-compose

#docker compose 버전 확인
$ docker-compose --version

```



### Docker 명령어

```bash
# 이미지 받기
$ docker pull [OPTIONS] NAME[:TAG|@DIGEST]

# 이미지 보기
$ docker images [OPTIONS] [REPOSITORY[:TAG]]

# 이미지 태그 생성
$ docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]

# 이미지 삭제
$ docker rmi [OPTIONS] IMAGE [IMAGE...]

# 모든 이미지 삭제
$ docker rmi $(docker images -q)

# 컨테이너 실행
$ docker run [OPTIONS] IMAGE [COMMAND] [ARG...]

# 컨테이너 재실행
$ docker restart [OPTIONS] CONTAINER [CONTAINER...]

# 컨테이너 보기
$ docker ps [-option]

# 컨테이너 중지
$ docker stop [-option] [container ID]

# 컨테이너 삭제
$ docker rm [-option] [container ID]

# 중지된 컨테이너 삭제
$ docker rm $(docker ps -a -q -f status=exited)

# 모든 컨테이너 삭제
$ docker rm $(docker ps -qa)

# 도커HUB 로그인
$ docker login

# 도커HUB Repository에 push
$ docker push [OPTIONS] NAME[:TAG]

# 도커 컨테이너 내부 접근
docker exec -it  [container ID] /bin/bash
```

참고 : [Docker Doc](https://docs.docker.com/get-started/overview)





### docker-compose.yml

```yaml
#docker-compose
version: '3.1'

services:
        
  reverse-proxy:
    image: nginx:1.17.6-alpine
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./proxy:/etc/nginx/conf.d
      - /etc/letsencrypt:/etc/letsencrypt
      - /var/www/letsencrypt:/var/www/letsencrypt
      - ./nginx/log:/var/log/nginx
      - ./frontend/:/var/www/html

    ports:
      - 80:80
      - 443:443
    
  jenkins:
    image: jenkins/jenkins:jdk11
    volumes:
      - ./jenkins_home:/var/jenkins_home
    environment:
      - JENKINS_OPTS="--prefix=/jenkins"
    ports:
      - 8080:8080

  spring:
    image: hansup:latest
    #environment:
    #  - GOOGLE_APPLICATION_CREDENTIALS=/tmp/keys/gambti-9002f-firebase-adminsdk-dgfmx-ebf4c391c0.json
    #volumes:
    #  - ./keys:/tmp/keys
    networks:
      - default
```



### dockerfile

```dockerfile
#자바 버전
FROM openjdk:8-jdk

#포트
EXPOSE 8080

#애플리케이션 추가 (jar)
ADD ./[jar 이름]-0.0.1-SNAPSHOT.jar [만들고싶은 이름].jar

#실행 명령
ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","[넣고싶은 이름].jar"]
```



만든 이미지 실행

```bash
$ docker image build -t [넣고 싶은 이름(이미지 이름으로 사용함)] .
$ docker run --name [이름] [이미지 이름]
```





# Nginx

### 버전 

stable version인 nginx-1.18.0 를 사용합니다.

### nginx.conf

```basic
# nginx.conf

user nginx;
worker_processes 3;

pid         /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    access_log  /var/log/nginx/access.log;
    error_log   /var/log/nginx/error.log;

    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    sendfile        on;
    keepalive_timeout  65;
    include /etc/nginx/conf.d/*.conf;
}
```



### proxy.conf

```yaml
#proxy conf
server {
  listen 80;
  server_name k4b208.p.ssafy.io;
  return 301 https://$host$request_uri;
}

server {
  listen 80;
  server_name 13.209.85.224;
  return 301 https://k4b208.p.ssafy.io$request_uri;
}

server {
  listen 443 ssl;
  server_name k4b208.p.ssafy.io;
  ssl_certificate /etc/letsencrypt/live/k4b208.p.ssafy.io/fullchain.pem;
  ssl_certificate_key /etc/letsencrypt/live/k4b208.p.ssafy.io/privkey.pem;
  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
  ssl_ciphers HIGH:!aNULL:!MD5;
  
  #엑세스 로그, 오류 로그를 남길 파일 경로 지정
  access_log /var/log/nginx/access.log;
  error_log /var/log/nginx/error.log;
  
  #static pages root & index 설정
  root /var/www/html;
  index index.html index.htm;
  
  #error 나면 그냥 index로 이동하도록 설정해둠
  location / {
    proxy_intercept_errors on;
    try_files $uri $uri/ /index.html;
  }
  
  #jenkins container 접근
  location /jenkins {
    proxy_set_header Host $host:$server_port;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_redirect off;
    proxy_pass http://jenkins:8080;
    # Required for new HTTP-based CLI
    proxy_http_version 1.1;
    proxy_request_buffering off;
    proxy_buffering off; # Required for HTTP-based CLI to work over SSL
    # workaround for https://issues.jenkins-ci.org/browse/JENKINS-45651
  }

  #restAPI container 접근
  location /api {
    rewrite /api/(.*) /api/$1 break;
    proxy_pass http://spring:8081;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Host $http_host;
  }
}
```





참고 :

프록시 서버란
https://interconnection.tistory.com/27

프록시 서버 예제
https://www.joinc.co.kr/w/man/12/proxy


프록시 서버, 캐시 서버, 웹 정적 서버
https://kscory.com/dev/nginx/setting

캐시 서버
https://www.joinc.co.kr/w/man/12/nginx/static


도커 compose
https://bum752.github.io/posts/Docker%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%B4-%EC%9B%B9-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EA%B3%BC-NGINX-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-(with-docker-compose)/

도커로 배포
https://medium.com/@nsh235482/docker%EB%A1%9C-%ED%98%91%EC%97%85%ED%95%98%EA%B8%B0-node-js-%EC%9B%B9%EC%84%9C%EB%B2%84%EB%A5%BC-docker%EB%A1%9C-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0-1475c33a4394

nginx
https://docs.nginx.com/nginx/admin-guide/web-server/web-server/
https://jojoldu.tistory.com/267



